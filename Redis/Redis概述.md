# Redis

Redis 是一个开源的，基于键值对（key-value）的 **非关系型数据库**（NoSQL）数据库，对数据的读写操作都是在内存中完成，因此 **读写速度非常快**，常用于 **缓存，消息队列、分布式锁等场景**

## 特性

### 1. 速度快

Redis 执行命令的速度非常快，官方给出的数字是读写性能可以达到 **10 万/秒**

1. **所有数据都是存放在内存中**
2. **由 C 语言实现**，一般来说 C 语言实现的程序距离操作系统更近，执行速度相对会更快
3. 使用了 **单线程架构**，预防了多线程可能产生的竞争问题
    - 线程安全：Redis 实际上是采用了线程封闭的观念，把任务封闭在一个线程，自然避免了线程安全问题，所以 **Redis 的所有操作都是原子性的**，同时还支持对几个操作合并后的原子性执行
4. **非阻塞 I/O**，Redis 使用 epoll 作为 **I/O 多路复用** 技术的实现，再加上 Redis 自身的事件处理模型将 epoll 中的连接、读写、关闭都转换为事件，不在网络 I/O 上浪费过多的时间
5. 作者对于 Redis 源代码可以说是精打细磨，曾经有人评价 Redis 是少有的集性能和优雅于一身的开源代码

### 2. 持久化

提供了 RDB 和 AOF，可以将数据的更新异步的保存到磁盘中

### 3. 多种数据结构

1. 主要提供 5 种数据结构：**字符串、哈希、列表、集合、有序集合**

2. 还提供位图（BitMap）、HyperLogLog、地理信息定位（GEO）、流（Stream）等

3. 方便开发者的使用

### 4. 支持多种编程语言

Redis 提供了简单的 TCP 通信协议，很多编程语言可以很方便地接入到 Redis，如 Java、PHP、Python、Lua 等

### 5. 功能丰富

1. 提供了键过期功能，可以用来实现缓存

2. 提供了发布订阅功能，可以用来实现消息系统

3. 支持 Lua 脚本功能，可以利用 Lua 创造出新的 Redis 命令

4. 提供了简单的事务功能，能在一定程度上保证事务特性

5. 提供了流水线（Pipeline）功能，这样客户端能将一批命令一次性传到 Redis，减少了网络的开销

### 6. 简单稳定

1. 源代码十分简洁

2. 使用了单线程模型

3. 不需要依赖外部库

4. 虽然简单，但十分稳定

### 7. 主从复制

1. Redis 提供了复制功能，实现了多个相同数据的 Redis 副本，复制功能是分布式 Redis 的基础

2. 主服务器执行修改，从服务器负责查询

### 8. 高可用与分布式

1. 提供了高可用实现 Redis Sentinel，它能够保证 Redis 节点的故障发现和故障自动转移

2. 提供了分布式实现 Redis Cluster，它是 Redis 真正的分布式实现，提供了高可用、读写和容量的扩展性

## 缺点

1. **数据库容量受到物理内存的限制**，不能用作海量数据的高性能读写
   - 一般只使用缓存存储一些 **常用和主要的数据**

2. **不具备自动容错和恢复功能**，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的 IP 才能恢复

3. 主机宕机，宕机前有部分数据未能及时同步到从机，切换 IP 后还会引入数据不一致的问题，降低了 **系统的可用性**

4. **较难支持在线扩容**，在集群容量达到上限时在线扩容会变得很复杂。所以在上线时必须确保有足够的空间，这对资源造成了很大的浪费

## Redis 是单线程的吗

我们常说 Redis 是单线程的，这个说法其实不太准确，Redis 在网络 IO 和命令操作是由一个线程完成的，但对于其他的功能都是由额外的线程执行的。且在 6.0 版本后网络 IO 也采用了多线程来处理，所以目前只有命令操作还在使用单线程

### 单线程的优势

- 使用单线程可以避免频繁的上下文切换
- 多线程开发中并发访问控制较复杂，即便增加了线程，系统吞吐率也不会随着线程的增加而增加，因为大部分线程还需等待获取访问共享资源的互斥锁

### 单线程的劣势

- 无法发挥多核 CPU 的优势
- 当删除大建，会导致服务阻塞
- QPS 达到瓶颈

### 后台线程

- Redis 在 2.6 版本，会启动 2 个后台线程，分别处理关闭文件、AOF 刷盘这两个任务
- Redis 在 4.0 版本之后，新增了 lazyfree 线程，用来异步释放 Redis 内存

Redis 创建这些后台线程，是因为这些操作都很耗时，如果都交给主线程来处理，很容易导致主线程阻塞

![](.\md.assets\bio.png)

后台线程相当于一个消费者，生产者把耗时任务丢到任务队列中，消费者不停轮询这个队列，拿出任务就去执行对应的方法即可

- Redis 在启动时，会同时启动这三个后台线程，但后台线程只有在需要执行相关类型后台任务时才会唤醒，其他时间会休眠等待任务

### 多进程

当 Redis 需要处理一些重负荷任务时，会 fork 一个子进程来处理

- 收到 bgrewriteaof 命令：Redis 构建子进程，然后子进程往临时 AOF 文件中写入重建数据库状态的所有命令。写入完毕后，子进程会通知父进程把新增的写操作追加到临时 AOF 文件。最后将临时文件替换旧的 AOF 文件，并重命名
- 收到 bgsave 命令：Redis 构建子进程，子进程将内存中的所有数据通过快照做一次持久化落地，写入到 RDB 中
- 当需要进行全量复制：master 构建子进程，子进程将数据库快照保存到 RDB 文件。在写完 RDB 快照文件后，master 会把 RDB 发给 slave，同时将后续新的写指令都同步给 slave

### Redis 6.0 多线程

CPU 并不是制约 Redis 性能表现的瓶颈所在，更多情况下是受到内存大小和网络 IO 的限制。且使用单线程，可维护性高，避免了并发读写的一系列问题

- 增加了系统复杂度
- 线程切换的损耗
- 加锁解锁、死锁造成的性能损耗

多线程是 Redis 6.0 推出的一个新特性。随着网络硬件的性能提升，单个线程处理⽹络请求的速度跟不上底层⽹络硬件的速度，导致网络 IO 的处理成为了 Redis 的性能瓶颈

Redis 6.0 的多线程特性默认只处理写请求，而如果想读请求也使用多线程来处理，则需要修改配置

```bash
# 读请求也使用IO多线程
io-threads-do-reads yes

# IO多线程个数
# 建议数量小于CPU核心数
# 注意主线程也算一个IO线程，所以最终会启动 n - 1 个IO线程
io-threads 4
```

## IO 多路复用

由于读写操作等待用户输入输出都是阻塞的，所以 IO 操作在一般情况下往往不能直接返回结果，这就会导致阻塞，致使整个进程无法为其他用户提供服务

为了让单线程的服务能同时应对多个客户端的请求，Redis 采用了 IO 多路复用模型

IO 多路复用其实是使用一个线程来检查多个文件描述符（比如socket）的就绪状态，多路复用的函数将返回变化的文件描述符

![](.\md.assets\epoll.png)

## 为什么要使用缓存

- 在日常的 Web 应用对数据库的访问中，**读操作的次数远超写操作**

- **高性能**：当用户第一次访问数据库中的某些数据，是从硬盘上读取的，所以过程会比较慢。将该用户访问的数据存在缓存中，再访问这些数据的时候就可以直接从缓存中获取了。**操作缓存就是直接操作内存，所以速度相当快**

- **高并发**：缓存能够承受的请求是远远大于直接访问数据库的，**极大减小数据库的压力**，可以把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库

- 不建议使用缓存的场景
  
  - 业务数据不常用， 命中率很低
  - 写操作多，频繁需要写入数据库
  - 如果要存储几百兆字节的文件，会给缓存带来很大的压力

## 为什么要使用 Redis 而不用 Map 做缓存

1. **Map 是本地缓存**，最主要的特点是轻量以及快速，如果有多台实例的话，**每个实例都需要各自保存一份缓存，缓存不具有一致性**。生命周期随着 JVM 的销毁而结束，而且 JVM 内存太大容易挂掉的，一般用做于容器来存储临时数据
   - Map 所存储的数据结构，缓存过期机制等需要程序员自己手写的

2. **Redis 是分布式缓存**，如果有多台实例的话，**每个实例都共享一份缓存，缓存具有一致性**。缺点是需要保持 Redis 服务的高可用，整个程序架构上较为复杂
   - 原生提供丰富的数据结构、缓存过期机制等简单好用的功能

## 通用命令

- Redis 命令 **大小写不敏感**

```bash
# 通过正则表达式查找key
# 常用keys *查找所有key
keys [pattern]

# 查看key总数
dbsize

# 检查key是否存在
exists <key>

# 删除指定key及其对应的值
del <key>

# 修改key的名称
rename <key> <newkey>

# 设置过期时间
expire <key> <seconds>

# 查看key的剩余过期时间
# 返回-1，该key未设置过期时间
# 返回-2，该key不存在
ttl <key>

# 移除key的过期时间
persist <key>

# 查看key的数据类型
type <key>

# 查看key的内部编码
object encoding <key>

# 清除数据库
flushall

# 随机返回一个key
randomkey
```

## 事务

## pipeline

## 阻塞

## 参考

- [2 万字 + 20张图｜ 细说 Redis 九种数据类型和应用场景](https://mp.weixin.qq.com/s/r9_0xpRsp2ubgyvpiyMfuw)
- [面试官：你确定 Redis 是单线程的进程吗？](https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247516338&idx=2&sn=481c0c5ba605eddbc4824056d941a261&chksm=f98dc418cefa4d0ec4e8e3e2a1c1badc6cb66b5c20775ff785b8ef0da708cf8eb0a1c42c236f&scene=178&cur_album_id=1790401816640225283#rd)
- [面试官问，Redis 是单线程还是多线程?我懵了](https://segmentfault.com/a/1190000041275783)
- [Redis之I/O多路复用模型实现原理](https://blog.csdn.net/Seky_fei/article/details/106677043)
- [Redis系列--数据过期清除策略&缓存淘汰策略](https://blog.csdn.net/weixin_42972832/article/details/131410757)
- [LRU和LFU 算法（页面置换算法）](https://blog.csdn.net/weixin_43240734/article/details/123159387)
- [别再搞混了！](https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247515536&idx=1&sn=2a9b1d82338516976105ae9342c011a6&chksm=f98df93acefa702cda29c86d77d6116adf812c4e15978dc916447e0f68e42a002520787f66a8&scene=178&cur_album_id=1790401816640225283#rd)
- [面试官：Redis 大 key 要如何处理？](https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247518433&idx=2&sn=e78f630c07f4e60fb78999eb3d742e9e&chksm=f98dcc4bcefa455d8ffde9ad6c8da9b3371a401766a55cbee7af11c87be070d823c8d5926aef&scene=178&cur_album_id=1790401816640225283#rd)
