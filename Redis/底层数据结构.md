## 数据结构与底层数据结构的关系演变

#### Redis 3.2 之前

| String | Hash      | List       | Set       | Zset     |
|:------:|:---------:|:----------:|:---------:|:--------:|
| SDS    | hashtable | linkedlist | hashtable | skiplist |
|        | ziplist   | ziplist    | intset    | ziplist  |

#### Redis 3.2 之后

| String | Hash      | List      | Set       | Zset     |
|:------:|:---------:|:---------:|:---------:|:--------:|
| SDS    | hashtable | quicklist | hashtable | skiplist |
|        | ziplist   |           | intset    | ziplist  |

#### Redis 7.0

| String | Hash      | List     | Set       | Zset     |
|:------:|:---------:|:--------:|:---------:|:--------:|
| SDS    | hashtable | listpack | hashtable | skiplist |
|        | listpack  |          | intset    | listpack |

#### Redis 7.2

| String | Hash      | List     | Set       | Zset     |
|:------:|:---------:|:--------:|:---------:|:--------:|
| SDS    | hashtable | listpack | hashtable | skiplist |
|        | listpack  |          | intset    | listpack |
|        |           |          | listpack  |          |

## Redis 是如何存储数据的

在 Redis 中，使用了一个哈希表保存所有键值对

![](.\md.assets\redisdb.png)

- redisDb：数据库的结构，结构体里存放了指向了 dict 结构的指针
- dict：结构体里存放了 2 个哈希表，正常情况下都是用哈希表 1，哈希表 2 只有在 rehash 的时候才用
- ditctht：哈希表的结构，结构里存放了哈希表数组，数组中的每个元素都是指向一个 dictEntry 的指针
- dictEntry：哈希表节点的结构，结构里存放了 `*key` 和 `*val` 指针，`*key` 指向的是 String 对象，而 `*val` 则可以指向 String 对象，也可以指向集合类型的对象

### redisObject

`*key` 和 `*val` 指针指向的都是 Redis 对象（redisObject），所以 Redis 中的 key 对象和 value 对象都是 redisObject

![](.\md.assets\redisobject.png)

- type：对象类型
- encoding：该类型的编码方式
- ptr：指向对象实际的数据结构的指针

### 哈希冲突

Redis 使用了 **链地址法 + 再哈希法** 来解决哈希冲突。详见哈希表的哈希冲突

## 底层数据结构

### 1. 简单动态字符串（SDS，Simple Dynamic String）

Redis 虽然是由 C 语言实现的，但并没有直接使用 C 语言的字符串表示，而是自己封装了 SDS 数据结构来表示字符串

#### 1.1 C 语言字符串的不足之处

##### 字符串的结尾用 `\0` 表示

如果字符串里面就包含有 `\0`，字符串就会被截断，因此不能保存二进制数据

![](.\md.assets\cstring.png)

##### 获取字符串长度的时间复杂度为 O(n)

获取字符串长度的 `strlen` 函数，需要遍历字符数组，直到遇到 `\0` 停止，然后才能返回字符串的长度

![](.\md.assets\clength.png)

##### 字符串操作函数不高效且不安全

C 语言的字符串不会记录自身的缓冲区大小，可能会有缓冲区溢出的风险，有可能会造成程序运行终止

#### 1.2 SDS 的结构设计

![](.\md.assets\sds.png)

- len：字符串长度
- alloc：分配给字符数组的空间长度
- flags：SDS 的类型
- buf[]：字符数组，用来保存实际的数据

#### 1.3 SDS 的优点

##### 二进制安全

二进制安全是指通过某种机制，保证读写字符串的时候不损害其内容。简而言之就是不会像 C 语言的字符串那样，字符串中有 `\0` 就截断了

##### 获取字符串长度的时间复杂度为 O(1)

直接返回 len 的值

##### 不会发生缓冲区溢出

在修改字符串的时候，可以通过 `alloc - len` 计算出剩余的空间大小，如果空间不能满足修改的需求，则会先将 SDS 的空间扩展到合适的大小，再执行修改的操作

- 只当空间不足的时候才会扩容，可有效的减少内存分配次数

##### 兼容性

SDS 的数据实际都存放在 buf[] 中，且向上暴露的指针也是直接指向 buf[] 的，而且 SDS 为了兼容性，还是会在字符串结尾加上 `\0` 字符。这样上层就可以像读取 C 语言字符串一样读取 SDS 中的内容了，兼容了 C 语言处理字符串的各种函数

##### 节省内存空间

SDS 为了能灵活保存不同大小的字符串，从而能有效节省内存空间，设计了 5 种类型，分别是 sdshdr5、sdshdr8、sdshdr16、sdshdr32 和 sdshdr64

SDS 还使用了专门的编译优化来节省内存空间，会告诉编译器取消结构体在编译过程中的优化对齐，按照实际占用字节数进行对齐

### 2. 整数集合（intset）

Set 对象的底层实现之一。当一个 Set 对象只包含整数值元素，并且元素数量不多时，就会使用整数集作为底层实现

- 元素数量不能超过 `set-max-intset-entries` 设定的值，默认为 512

#### 2.1 整数集合的结构设计

- encoding：编码方式
  - INTSET_ENC_INT16：占用 2 个字节，存储范围为 `-2^16 ~ 2^16 - 1`
  - INTSET_ENC_INT32：占用 4 个字节，存储范围为 `-2^32 ~ 2^32 - 1`
  - INTSET_ENC_INT64：占用 8 个字节，存储范围为 `-2^64 ~ 2^64 - 1`
- length：集合包含的元素数量
- contents[]：保存元素的数组
  - 数组的类型取决于 encoding 属性的值

#### 2.2 整数集合的升级操作

当添加的元素类型比目前所有元素的类型都要大时，整数集合会在原本的数组上扩展空间，然后在将每个元素按间隔类型大小分割

- 整数集合不支持降级操作

![](.\md.assets\intsetupdate-1.png)

![](.\md.assets\intsetupdate.png)

##### 整数集合升级的好处

当只需要保存一些较小的整数时，直接使用 int64_t 的数组，会造成内存的浪费。而直到存储的整数所需的类型大于当前的类型，才进行升级，可以有效的节省内存资源

### 3. 跳表（skiplist）

在 Redis 中只有 zset 使用了跳表，跳表在查找、删除、添加等操作的时间复杂度都是 O(logn)，但需要的存储空间较大

- 当且仅当超过 listpack（7.0 之前为 ziplist）的限制时，zset 才会使用跳表作为内部实现
  - 元素数量大于 `zset-max-listpack-entries`，默认值为 128
  - 或元素大小大于 `zset-max-listpack-entries`，默认值为 64 字节

zset 对象是唯一一个 **同时** 使用了两个数据结构来实现的 Redis 对象。zset 能进行高效的范围查询，是因为采用了跳表。能进行高效单点查询，以常数复杂度获取元素权重，是因为采用了哈希表作为索引

#### 3.1 跳表的结构设计

跳表是在链表基础上改进过来的，实现了一种多层的有序链表，这样的好处是能快读定位数据

![](.\md.assets\skiplist.png)

- header：头结点
- tail：尾节点
- length：节点总数
- level：最大层数
- zskiplistNode：跳表节点
  - ele：存储的元素
  - score：权重分值
  - level[]：层级数组
    - forward：前向指针
    - span：与下一个节点的跨度

![](.\md.assets\level.png)

跳表就是通过 level[] 实现了层级间的跳转

#### 3.2 跨度

跨度实际上是为了计算这个节点在跳表中的排位，将到达目标节点之间的跨度相加，得到的结果就是该目标节点在跳表中的排位

#### 3.3 查询

跳表会从头节点的最高层开始，逐一遍历每一层，当该层没有找到目标节点，或者已确定范围，则向下一层的当前节点处开始遍历，直到找到目标节点

#### 3.4 层数

相邻两层的节点数量的比例过大或过小都会影响跳表的查询性能。最理想的比例是 `2 : 1`

zset 在创建节点时，随机生成节点的层数，会随机生成一个范围在 `0 ~ 1` 的随机数，如果随机数小于 0.25，则层数增加 1 层，然后继续生成下一个随机数，直到随机数的结果大于 0.25，最终确定该节点的层数

层数越高，概率越低，当数据量足够时，相邻两层的节点数量比例趋近于 `2 : 1`

```c
int zslRandomLevel(void) {
    int level = 1;
    while ((random()&0xFFFF) < (ZSKIPLIST_P * 0xFFFF))
        level += 1;
    return (level<ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;
}
```

### 4. 哈希表（hashtable）

hash 和 set 都使用了哈希表作为底层实现

- 当且仅当超过 listpack（7.0 之前为 ziplist）的限制时，hash 才会使用哈希表作为内部实现
  
  - 元素数量大于 `hash-max-listpack-entries`，默认值为 512
  
  - 或元素大小大于 `hash-max-listpack-value`，默认值为 64 字节

- 当且仅当超过 listpack（7.2 新增）的限制时，set 才会使用哈希表作为内部实现
  
  - 即元素数量大于 `set-max-listpack-entries`，默认值为 128
  
  - 或元素大小大于 `set-max-listpack-entries`，默认值为 64 字节

#### 4.1 哈希表的结构设计

![](.\md.assets\hashtable.png)

- table：哈希表数组
- size：哈希表大小
- used：该哈希表已有的节点数量

#### 4.2 哈希冲突

Redis 使用了 **链地址法 + 再哈希法** 来解决哈希冲突。Redis 会先将哈希冲突的元素加入到链表中，当链表中的元素越来越多时，查询性能降低，则会使用 rehash 法，对哈希表的大小进行扩展

##### rehash

Redis 在 dict 结构体中定义了两个哈希表。正常情况下插入的元素都会写入到哈希表 1，此时的哈希表 2 并没有被分配空间，当链地址法的性能下降时，则会触发 rehash 操作

1. 给哈希表 2 分配空间，一般会比哈希表 1 大 2 倍
2. 将哈希表 1 的数据迁移到哈希表 2 中
3. 迁移完成后，哈希表 1 的空间会被释放，并把哈希表 2 设置为哈希表 1，然后在哈希表 2 新创建一个空白的哈希表，为下次 rehash 做准备

![](.\md.assets\rehash.png)

##### 渐进式 rehash

当哈希表中数据量很大时，在迁移的过程中涉及了大量的数据拷贝，可能会对 Redis 造成阻塞，影响性能。为了避免此类问题，Redis 使用了渐进式 rehash，即将数据的迁移的工作不再是一次性迁移完成，而是分多次迁移

1. 给哈希表 2 分配空间
2. 在 rehash 进行期间，每次哈希表元素进行操作时，Redis 除了会执行对应的操作之外，还会顺序的将哈希表 1 中索引位置上的所有键值对迁移到哈希表 2 上
3. 随着处理客户端发起的哈希表操作请求数量越多，最终在某个时间段内，会把哈希表 1 的所有键值对迁移到哈希表 2，从而完成 rehash 操作

在渐进式 rehash 进行期间，新增一个键值对时，会被保存到哈希表 2 里面，而哈希表 1 则不再进行任何添加操作，这样保证了哈希表 1 的键值对数量只会减少，随着 rehash 操作的完成，最终哈希表 1 就会变成空表

##### rehash 的触发条件

rehash 的触发条件跟负载因子（load factor）有关，`负载因子 = 哈希表已保存的节点数 / 哈希表大小`

- 当负载因子大于等于 1 ，并且 Redis 没有在执行 bgsave 命令或者 bgrewiteaof 命令，也就是没有执行 RDB 快照或没有进行 AOF 重写的时候，就会进行 rehash 操作
- 当负载因子大于等于 5 时，此时说明哈希冲突非常严重了，不管有没有有在执行 RDB 快照或 AOF 重写，都会强制进行 rehash 操作

### 5. 双端列表（linkedlist）

在 3.2 版本之后 Redis 已经没有再直接用过双端列表作为底层数据结构了，而是使用 linkedlist + ziplist 的组合 quicklist 作为列表的内部实现，再到 7.0 版本的时候使用 listpack 作为列表的内部实现

#### 5.1 双端列表的结构设计

![](.\md.assets\linkedlist.png)

- head：链表头指针
- tail：链表尾指针
- len：链表节点数量
- dup、free、match：自定义实现的函数

#### 5.2 优点

- 获取头尾节点的时间复杂度为 O(1)
- 获取某个节点的前驱节点或后继节点的时间复杂度为 O(1)
- 因为提供了链表节点数量 len，所以获取链表中的节点数量的时间复杂度只需 O(1)
- 链表节点可以保存各种不同类型的值

#### 5.3 缺点

- 链表每个节点之间的内存都是不连续的，意味着 **无法很好利用 CPU 缓存**

- 每个节点除了保存节点的值，还需要保存节点的结构头，**内存开销较大**

### 6. 压缩列表（ziplist）

在 3.2 版本之后 hash 和 zset 会在所含元素数量较少，或元素值不大的情况下使用压缩列表作为内部实现，直到 7.0 版本的时候使用 listpack 彻底取代了 ziplist

- 当且仅当满足 ziplist 的限制时，hash 才会使用压缩列表作为内部实现
  
  - 元素数量小于 `hash-max-ziplist-entries`，默认值为 512
  
  - 或元素大小小于 `hash-max-ziplist-value`，默认值为 64 字节

- 当且仅当满足 ziplist 的限制时，zset 才会使用压缩列表作为内部实现
  
  - 即元素数量小于 `zset-max-ziplist-entries`，默认值为 128
  
  - 或元素大小小于 `zset-max-ziplist-entries`，默认值为 64 字节

#### 6.1 压缩列表的结构设计

![](.\md.assets\ziplist.png)

- zlbytes：列表占用堆内存字节数
- zltail：记录列表尾节点距离起始地址有多少字节，即列表尾节点的偏移量
- zllen：列表的节点数量
- zlend：标记列表的结束点，固定值 `0xFF`
- entry：列表节点
  - prevlen：记录前驱节点的长度
  - encoding：当前节点实际数据的类型及长度
  - data：记录当前节点的实际数据

#### 6.2 prevlen 的大小

- 如果前驱节点的长度 **小于 254 字节**，prevlen 需要 **1 字节** 的空间来保存这个长度值
- 如果前驱节点的长度 **大于等于 254 字节**，prevlen 需要 **5 字节** 的空间来保存这个长度值

#### 6.3 encoding 的大小

- 如果当前节点的数据是 **整数**，encoding 会使用 **1 字节** 的空间进行编码
- 如果当前节点的数据是 **字符串**，根据字符串的长度大小，encoding 会使用 **1 字节 / 2 字节 / 5 字节** 的空间进行编码

#### 6.4 ziplist 为什么要记录前一个节点的长度

ziplist 并没有维护指针，而是保存了前一个节点的长度和当前节点的长度，虽然牺牲了读取性能但是获得了更多的存储空间，即用时间换空间

ziplist 为了支持尾部遍历，所以需要记录前一个节点的长度，这样用当前尾部节点的地址减去前一个节点的长度，就能够拿到前一个节点了

#### 6.5 优点

- 压缩列表是一种内存紧凑型的数据结构，占用一块连续的内存空间，可以有效的利用 CPU 缓存

- 会根据数据大小和类型，进行相应编码，从而进行不同的空间大小分配，有效地节省内存开销

#### 6.6 缺点

- 不能保存过多的元素，否则查询效率就会降低
  
  - 除了头尾节点，查找其他节点都需要遍历列表

- 新增或修改某个元素时，压缩列表占用的内存空间需要重新分配，甚至可能引发连锁更新的问题
  
  - 连锁更新：当操作某个元素时，且空间不够，需要扩容时，可能会导致后续元素的 prevlen 占用空间都发生变化，每个空间都需要重新分配，造成访问性能下降
  - 所以压缩列表只会用于保存的节点数量不多的场景，只要节点数量足够小，即使发生连锁更新，也是能接受的

![](.\md.assets\chainupdate-1.png)

![](.\md.assets\chainupdate.png)

### 7. 快速列表（quicklist）

7.0 版本之后 quicklist 被 listpack 取代，在之前为了解决 ziplist 的不足，被用作 List 的底层实现

其实 quicklist 就是 linkedlist + ziplist 的组合，因为一个 quicklist 就是一个链表，而链表中的每个元素又是一个压缩列表

#### 7.1 快速列表的结构设计

![](.\md.assets\quicklist.png)

- head：链表头指针
- tail：链表尾指针

#### 7.2 解决了但没完全解决连锁更新问题

quicklist 通过控制每个链表节点中的压缩列表的大小或者元素个数，来规避连锁更新的问题。因为压缩列表元素越少或越小，连锁更新带来的影响就越小，从而提供了更好的访问性能

向 quicklist 添加元素时，不会直接新建一个链表节点。而是会先检查插入位置的压缩列表是否能容纳该元素，如果能容纳就直接保存到压缩列表里，如果不能容纳，才会新建一个新的 quicklistNode 结构

quicklist 会控制 quicklistNode 结构里的压缩列表的大小或者元素个数，来规避潜在的连锁更新的风险，但是这并没有完全解决连锁更新的问题

### 8. 紧凑列表（listpack）

listpack 是在 5.0 版本推出的，目的是替代 ziplist，而在 7.0 版本之后才正式开始替换。listpack 也是使用范围最广的底层数据结构，除了字符串外，其他 4 种基本数据结构的内部实现中都有 listpack 的身影

- 当且仅当满足 listpack 的限制时，hash 才会使用哈希表作为内部实现
  
  - 元素数量小于 `hash-max-listpack-entries`，默认值为 512
  
  - 或元素大小小于 `hash-max-listpack-value`，默认值为 64 字节

- 当且仅当满足 listpack（7.2 新增）的限制时，set 才会使用哈希表作为内部实现
  
  - 即元素数量小于 `set-max-listpack-entries`，默认值为 128
  
  - 或元素大小小于 `set-max-listpack-entries`，默认值为 64 字节

- 当且仅当满足 listpack 的限制时，zset 才会使用哈希表作为内部实现
  
  - 即元素数量小于 `zset-max-listpack-entries`，默认值为 128
  
  - 或元素大小小于 `zset-max-listpack-entries`，默认值为 64 字节

#### 8.1 紧凑列表的结构设计

![](.\md.assets\listpack.png)

- encoding：定义该元素的编码类型，会对不同长度的整数和字符串进行编码
- data：实际存放的数据
- len：encoding + data 的总长度

结构总体上与 ziplist 类似，不同的是不需要像 ziplist 一样记录前一个节点的大小，而是记录当前元素的大小

当我们向 listpack 加入一个新元素的时候，不会影响其他节点的长度字段的变化，从而避免了压缩列表的连锁更新问题

## 引用

- [为了拿捏 Redis 数据结构，我画了 40 张图（完整版）](https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247501112&idx=1&sn=e42b6c61c6747e2c2f3b890ab4e4b844&chksm=f98d8192cefa0884606c5284499d76eeb3966ac2d3de9fbc4a405448313dcf79eb41b7c9501e&scene=178&cur_album_id=1790401816640225283#rd)
- [分类：Redis - Error's Blog](https://zygzyg.cloud/categories/redis)
- [Redis源码初识六 跳表(skiplist)数据结构](https://blog.csdn.net/u010883443/article/details/111187863)
