## 内存淘汰策略

当 Redis 的运行内存已经超过 Redis 设置的最大内存之后，则会使用内存淘汰策略删除符合条件的 key，以此来保障 Redis 高效的运行

```bash
# 设置最大运行内存
# 64位系统默认值为0，没有内存大小限制
# 32位系统默认值为3G，因为32位最大只支持4G的内存
maxmemory <bytes>

# 设置内存淘汰策略
maxmemory-policy <policy>
```

### 淘汰策略

#### 不进行数据淘汰

- noeviction：默认的内存淘汰策略，当运行内存超过最大设置内存时，不淘汰任何数据，而是不再提供服务，直接返回错误

#### 在设置了过期时间的数据中进行淘汰

- volatile-random：随机淘汰
- volatile-lru：淘汰最久未使用的
- volatile-lfu：淘汰最少使用的
- volatile-ttl：淘汰将要过期的

#### 在所有数据范围内进行淘汰

allkeys-random：随机淘汰
allkeys-lru：淘汰最久未使用的
allkeys-lfu：淘汰最少使用的

### 最近最少使用（LRU，Least Recently Used）

注重时间，最长时间未被使用的会被选择出来

#### 传统实现

基于链表结构，链表中的元素按照操作顺序从前往后排列，最新操作的键会被移动到表头，当需要内存淘汰时，只需要删除链表尾部的元素即可，因为链表尾部的元素就代表最久未被使用的元素

- 需要使用链表管理数据，会带来额外的空间开销
- 如果有大量的数据被访问，链表的移动也会增多，会很耗时，进而会降低 Redis 缓存性能

#### Redis 实现

Redis 在对象结构体中添加了一个用于记录该数据最后访问时间的字段。当 Redis 进行内存淘汰时，默认会随机取 5 个值，淘汰其中最久没用过的

- 近似 LRU 的算法，不用维护一个链表，可以更好的节约内存
- 不用在每次数据访问时都移动链表，提升了缓存的性能

但 LRU 无法解决 **缓存污染** 问题，如果一个数据被访问的次数很少，甚至只有一次，但仍可能留存在缓存中很长时间

### 最不常用（LFU，Least Frequently Used）

注重频率，一段时间内使用最少的会被选择出来

在 Redis 中 LRU 与 LFU 共用了一个字段，LRU 用来保存了最后访问的时间戳，而 LFU 将字段拆成了两份

![](./md.assets/lfu.png)

- ldt：记录 key 的访问时间戳
- logc：记录 key 的访问频率，值越小频率越低，初始值为 5

每次 key 被访问时，会先对 logc 做一个衰减操作。与之前的访问时间作比较，时间差距越大，衰减的值也就越大

做完衰减操作后，就开始做增加操作。增加操作并不是单纯的直接加 1，而是根据概率增加，logc 越大就越难再增加