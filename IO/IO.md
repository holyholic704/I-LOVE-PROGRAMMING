# 前置知识

IO，英文全称是Input/Output，翻译过来就是**输入/输出**

涉及计算机核心与其他设备间数据迁移的过程，就是IO

我们应用程序是跑在用户空间的，它不存在实质的IO过程，真正的IO是在**操作系统**执行的。即应用程序的IO操作分为两种动作：**IO调用和IO执行**。IO调用是由进程（应用程序的运行态）发起，而IO执行是**操作系统内核**的工作。此时所说的IO是应用程序对操作系统IO功能的一次触发，即IO调用。

上层程序的IO操作，实际上不是物理设备的级别的读写，而是缓存的复制

### 内核态，用户态

操作系统为了保护自己，设计了用户态、内核态两个状态。应用程序一般工作在用户态，当调用一些底层操作的时候（比如 IO 操作），就需要切换到内核态才可以进行。用户态和内核态的切换需要消耗一些资源，零拷贝技术就是通过减少用户态和内核态的转换来提高性能的。

### 系统调用

我们的应用程序运行在用户空间，是不具备系统级的直接操作权限的。如果应用程序想要访问系统核心功能，必须通过系统调用（System Call）来完成。

系统调用运行在内核空间，是操作系统为应用程序提供的接口。

### 操作系统的一次IO过程

应用程序发起的一次IO操作包含两个阶段：

- IO调用：应用程序进程向操作系统**内核**发起调用。

- IO执行：操作系统内核完成IO操作。

操作系统内核完成IO操作还包括两个过程：

- 准备数据阶段：内核等待I/O设备准备好数据

- 拷贝数据阶段：将数据从内核缓冲区拷贝到用户进程缓冲区

其实IO就是把进程的内部数据转移到外部设备，或者把外部设备的数据迁移到进程内部。外部设备一般指硬盘、socket通讯的网卡。一个完整的**IO过程**包括以下几个步骤：

- 应用程序进程向操作系统发起**IO调用请求**

- 操作系统**准备数据**，把IO外部设备的数据，加载到**内核缓冲区**

- 操作系统拷贝数据，即将内核缓冲区的数据，拷贝到用户进程缓冲区

![](.\md.assets\IO.png)

### 文件标识符

文件描述符在形式上是一个非负整数，实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。

### 缓存IO

大多数文件系统的默认 IO 操作都是缓存 IO。

其读写过程如下：

- **读操作**：操作系统检查内核的缓冲区有没有需要的数据，如果已经缓存了，那么就直接从缓存中返回；否则从磁盘、网卡等中读取，然后缓存在操作系统的缓存中；

- **写操作**：将数据从用户空间复制到内核空间的缓存中。这时对用户程序来说写操作就已经完成，至于什么时候再写到磁盘、网卡等中由操作系统决定，除非显示地调用了 sync 同步命令。

假设内核空间缓存无需要的数据，用户进程从磁盘或网络读数据分两个阶段：

- **阶段一：** 内核程序从磁盘、网卡等读取数据到内核空间缓存区；

- **阶段二：** 用户程序从内核空间缓存拷贝数据到用户空间。

缺点：数据在传输过程中需要在应用程序地址空间和内核空间进行多次数据拷贝操作，这些数据拷贝操作所带来的CPU以及内存开销非常大。

# IO 模型

同步和异步：同步和异步指的是用户空间和内核空间IO发起的方式。
同步IO只是用户空间的线程是主动发起IO的一方，内核空间是被动接受方。
异步IO则是反过来，系统内核是主动发起IO请求的一方，用户空间的线程是被动接受方。



阻塞和非阻塞：阻塞IO，指的是需要内核IO操作彻底完成后，才返回用户空间执行用户的操作。
非阻塞IO指的是用户空间的程序不需要等待内核IO操作彻底完成，可以立即返回用户空间执行用户的操作，即处于非阻塞的状态，
于此同时内核会立即返回给用户一个状态值。
换句话说就是，阻塞就是用户空间（调用线程）死等内核IO，这期间什么都不干。
非阻塞是用户空间（调用线程）拿到内核返回的状态就直接返回自己的空间，IO操作可以干就干，不可以干就去干别的事情。

### 1. 阻塞式 I/O 模型（blocking I/O）

当发起一个IO操作时，比如读取数据，系统会调用read()函数。如果请求的数据没有准备好，此时进程会被挂起（blocked），进入等待状态。直到数据准备好，而且复制到应用进程的缓冲区，这时候才会返回

- 阻塞IO的缺点就是：如果内核数据一直没准备好，那用户进程将一直阻塞，**浪费性能**，可以使用**非阻塞IO**优化。

**优点：**程序简单，在阻塞等待数据期间进程/线程挂起，基本不会占用 CPU 资源。  
**缺点：**每个连接需要独立的进程/线程单独处理，当并发请求量大时为了维护程序，内存、线程切换开销较大，这种模型在实际生产中很少使用。

![](.\md.assets\IO (1).png)

### 2. 非阻塞式 I/O 模型（non-blocking I/O）

所谓非阻塞IO，是在调用IO操作时，如果缓冲区没有数据的话，直接返回一个错误码。应用进程需要不断轮询，来检查数据是否准备好。数据准备好了，就返回数据。

- 相对于阻塞IO，虽然大幅提升了性能，但是它依然存在**性能问题**，即**频繁的轮询**，导致频繁的系统调用，同样会消耗大量的CPU资源。

**优点：**不会阻塞在内核的等待数据过程，每次发起的 I/O 请求可以立即返回，不用阻塞等待，实时性较好。  
**缺点：**轮询将会不断地询问内核，这将占用大量的 CPU 时间，系统资源利用率较低，所以一般 Web 服务器不使用这种 I/O 模型。

![](.\md.assets\IO (2).png)

### 3. I/O 复用模型（I/O multiplexing）

虽然非阻塞IO相比阻塞IO，性能提升了很多，但是轮询过程中，还是有大量的系统调用，上下文切换的开销比较大。

多路指的是多个数据通道，复用指的是一个进程可以同时监控多个文件描述符（比如socket），当某个文件描述符状态发生变化（比如变得可读或可写），多路复用的函数将返回变化的文件描述符。

这样，在数据传输过程中，同一个进程中不同的任务都能被处理。特点是在数据传输过程中，进程能够同时处理多个任务，提高了程序的效率。

IO复用模型核心思路：系统给我们提供**一类函数**（如我们耳濡目染的**select、poll、epoll**函数），它们可以同时监控多个`fd`的操作，任何一个返回内核数据就绪，应用进程再发起`recvfrom`系统调用。

- **优点：** 使用一个查询就绪状态的线程就可以同时同时轮询成千上万个连接。系统不必要创建和维护大量的线程，大大减小了系统的开销。
- **缺点：** select/epoll调用都是阻塞式的，属于同步IO。都需要在读写事件就绪后，由系统调用本身负责进行读写，也就是这个读写过程时阻塞的。

**优点：**可以基于一个阻塞对象，同时在多个描述符上等待就绪，而不是使用多个线程(每个文件描述符一个线程)，这样可以大大节省系统资源。  
**缺点：**当连接数较少时效率相比多线程+阻塞 I/O 模型效率较低，可能延迟更大，因为单个连接处理需要 2 次系统调用，占用时间会有增加。

#### select

应用进程通过调用**select**函数，可以同时监控多个`fd`，在`select`函数监控的`fd`中，只要有任何一个数据状态准备就绪了，`select`函数就会返回可读状态，这时应用进程再发起`recvfrom`请求去读取数据。

非阻塞IO模型（NIO）中，需要`N`（N>=1）次轮询系统调用，然而借助`select`的IO多路复用模型，只需要发起一次询问就够了,大大优化了性能。

但是呢，`select`有几个缺点：

- 监听的IO最大连接数有限，在Linux系统上一般为1024。

- select函数返回后，是通过**遍历**`fdset`，找到就绪的描述符`fd`。（仅知道有I/O事件发生，却不知是哪几个流，所以**遍历所有流**）

![](.\md.assets\IO (3).png)

#### poll

因为**存在连接数限制**，所以后来又提出了**poll**。与select相比，**poll**解决了**连接数限制问题**。但是呢，select和poll一样，还是需要通过遍历文件描述符来获取已经就绪的`socket`。如果同时连接的大量客户端，在一时刻可能只有极少处于就绪状态，伴随着监视的描述符数量的增长，**效率也会线性下降**。

#### epoll

为了解决`select/poll`存在的问题，多路复用模型`epoll`诞生，它采用事件驱动来实现

**epoll**先通过`epoll_ctl()`来注册一个`fd`（文件描述符），一旦基于某个`fd`就绪时，内核会采用回调机制，迅速激活这个`fd`，当进程调用`epoll_wait()`时便得到通知。这里去掉了**遍历文件描述符**的坑爹操作，而是采用**监听事件回调**的机制。这就是epoll的亮点。

**epoll**明显优化了IO的执行效率，但在进程调用`epoll_wait()`时，仍然可能被阻塞

![](.\md.assets\IO (4).png)

|         | select                         | poll                         | epoll                              |
| ------- | ------------------------------ | ---------------------------- | ---------------------------------- |
| 底层数据结构  | 数组                             | 链表                           | 红黑树和双链表                            |
| 获取就绪的fd | 遍历                             | 遍历                           | 事件回调                               |
| 事件复杂度   | O(n)                           | O(n)                         | O(1)                               |
| 最大连接数   | 1024                           | 无限制                          | 无限制                                |
| fd数据拷贝  | 每次调用select，需要将fd数据从用户空间拷贝到内核空间 | 每次调用poll，需要将fd数据从用户空间拷贝到内核空间 | 使用内存映射(mmap)，不需要从用户空间频繁拷贝fd数据到内核空间 |

### 应用场景

很容易产生一种错觉认为只要用 epoll 就可以了，select 和 poll 都已经过时了，其实它们都有各自的使用场景。

select 应用场景

select 的 timeout 参数精度为 1ns，而 poll 和 epoll 为 1ms，因此 select 更加适用于实时要求更高的场景，比如核反应堆的控制。

select 可移植性更好，几乎被所有主流平台所支持。

poll 应用场景

poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。

需要同时监控小于 1000 个描述符，就没有必要使用 epoll，因为这个应用场景下并不能体现 epoll 的优势。

需要监控的描述符状态变化多，而且都是非常短暂的，也没有必要使用 epoll。因为 epoll 中的所有描述符都存储在内核中，造成每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率。并且epoll 的描述符存储在内核，不容易调试。

epoll 应用场景

只需要运行在 Linux 平台上，并且有非常大量的描述符需要同时轮询，而且这些连接最好是长连接

### 4. 信号驱动式 I/O 模型（signal-driven I/O）

进程首先告诉内核，当数据准备好时，请发送一个SIGIO信号。进程继续执行其他任务，等到收到信号后，再开始进行数据传输。

信号驱动IO不再用主动询问的方式去确认数据是否就绪，而是向内核发送一个信号（调用`sigaction`的时候建立一个`SIGIO`的信号），然后应用用户进程可以去做别的事，不用阻塞。当内核数据准备好后，再通过`SIGIO`信号通知应用进程，数据准备好后的可读状态。应用用户进程收到信号之后，立即调用`recvfrom`，去读取数据。

信号驱动IO模型，在应用进程发出信号后，是立即返回的，不会阻塞进程。它已经有异步操作的感觉了。但是你细看上面的流程图，**发现数据复制到应用缓冲的时候**，应用进程还是阻塞的。

**优点：**线程并没有在等待数据时被阻塞，可以提高资源的利用率。  
**缺点：**信号 I/O 在大量 IO 操作时可能会因为信号队列溢出导致没法通知。

![](.\md.assets\IO (5).png)

### 5. 异步 I/O 模型（asynchronous I/O）

异步IO是指当发起一个IO操作后，系统会立即返回。异步IO操作在后台进行数据传输，数据传输完成后，系统将通知进程。这样，在整个数据传输的过程中，进程都可以执行其他任务，不需要等待。

前面讲的`BIO，NIO和信号驱动`，在数据从内核复制到应用缓冲的时候，都是**阻塞**的，因此都不算是真正的异步。`AIO`实现了IO全流程的非阻塞，就是应用进程发出系统调用后，是立即返回的，但是**立即返回的不是处理结果，而是表示提交成功类似的意思**。等内核数据准备好，将数据拷贝到用户进程缓冲区，发送信号通知用户进程IO操作执行完毕。

异步IO的优化思路很简单，只需要向内核发送一次请求，就可以完成数据状态询问和数据拷贝的所有操作，并且不用阻塞等待结果。

信号驱动 I/O 是由内核通知应用程序何时启动一个 I/O 操作，而异步 I/O 模型是由内核通知应用程序 I/O 操作何时完成。

- **优点：** 在内核等待数据和复制数据的两个阶段，用户线程都不是阻塞的。
- **缺点：** 需要操作系统底层内核提供支持。

**优点：**异步 I/O 能够充分利用 DMA 特性，让 I/O 操作与计算重叠。  
**缺点：**要实现真正的异步 I/O，操作系统需要做大量的工作。目前 Windows 下通过 IOCP 实现了真正的异步 I/O。

![](.\md.assets\IO (6).png)

### 总结

![](.\md.assets\五种IO模型总结.png)

| IO 模型   | 第一阶段       | 第二阶段 |
| ------- | ---------- | ---- |
| 阻塞式IO   | 阻塞         | 阻塞   |
| 非阻塞式IO  | 非阻塞        | 阻塞   |
| IO多路程复用 | 阻塞（Select） | 阻塞   |
| 信号驱动式IO | 异步         | 阻塞   |
| 异步IO    | 异步         | 异步   |

- 阻塞/非阻塞
  
  - 阻塞：阻塞 IO
  
  - 非阻塞：非阻塞 IO、多路复用 IO、信号驱动 IO、异步 IO

- 同步/异步
  
  - 同步：阻塞 IO、非阻塞 IO、多路复用 IO、信号驱动 IO
  
  - 异步：异步 IO

# JAVA 实现

### BIO

### NIO

### AIO

# 引用

- [Unix I/O模型与线程模型 | Elijah's Blog](https://elijahte.gitee.io/2021/01/07/Unix-IO%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/)

- [一顿饭的事儿，搞懂Linux5种IO模型](https://mp.weixin.qq.com/s/LYbJxorhsyoWWtP6OR6-eQ)

- [看一遍就理解：IO模型详解](https://mp.weixin.qq.com/s/bb7C6VNbq7REP9u8PsreSg)

- [半小时搞懂 IO 模型](https://mp.weixin.qq.com/s/gEc_XJ1WYKotZgOaFXe13A)

- [五种网络IO模型优缺点](https://zhuanlan.zhihu.com/p/511573605)

- [IO 模型 - Unix IO 模型 | Java 全栈知识体系](https://pdai.tech/md/java/io/java-io-model.html)

- [Linux的5种网络IO模型详解 - 苦涩的茶 - 博客园](https://www.cnblogs.com/liushui-sky/p/12917347.html)

- [深入理解网络 IO 模型 | 编程沉思录](https://www.cyhone.com/articles/reunderstanding-of-non-blocking-io/)

- [硬核图解网络IO模型！](https://mp.weixin.qq.com/s/fCGPemISp9JFjYEjTgAhAw)
