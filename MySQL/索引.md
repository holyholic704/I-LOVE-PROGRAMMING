# 索引

## 数据结构

### 二叉查找树（BST，Binary Search Tree）

![](./md.assets/bst_1.png)

<small>[【深入学习MySQL】MySQL的索引结构为什么使用B+树？ - 二叉查找树(BST)：不平衡](https://www.cnblogs.com/kismetv/p/11582214.html)</small>

- 任意节点的左子树上所有节点值不大于根节点的值
- 任意节点的右子树上所有节点值不小于根节点的值

当需要快速查找时，将数据存储在 BST 是一种常见的选择，因为此时查询时间取决于树高，平均时间复杂度是 O(logN)。然而，在某些情况下 BST 可能长歪而变得不平衡，此时 BST 退化为链表，时间复杂度退化为 O(N)

![](./md.assets/bst_2.png)

<small>[【深入学习MySQL】MySQL的索引结构为什么使用B+树？ - 二叉查找树(BST)：不平衡](https://www.cnblogs.com/kismetv/p/11582214.html)</small>

### 平衡二叉树（AVL Tree）

![](./md.assets/avl.jpg)

<small>[AVL树概念 AVL树旋转、插入、删除操作说明](https://fuxi.163.com/database/220)</small>

AVL 树是严格的平衡二叉树，所有节点的左右子树高度差不能超过 1。AVL 树查找、插入和删除在平均和最坏情况下都是 O(logN)

AVL 树为了维护严格的平衡性，在插入或删除元素时，会进行大量的维护平衡的操作，维护平衡所需的代价可能高于其带来的好处，因此 AVL 树实际使用并不广泛

### 红黑树（R-B Tree）

与 AVL 树相比，红黑树并不追求严格的平衡，而是大致的平衡，确保从根到叶子的最长的可能路径不多于最短的可能路径的两倍长

- 每个节点要么是黑色要么是红色
- 根节点是黑色
- 所有叶子节点都是黑色，并且为空节点
- 每个红色节点必须有两个黑色的子节点
- 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点

![](./md.assets/Red-black_tree_example.svg.png)

<small>[红黑树](https://zh.wikipedia.org/zh-cn/%E7%BA%A2%E9%BB%91%E6%A0%91)</small>

红黑树允许少量的不平衡，省去了很多的平衡操作，也就有了更好的插入或删除的效率

对于数据在内存中的情况，红黑树的表现是非常优异的。但是对于数据在磁盘中的情况，红黑树并不擅长，因为红黑树长得还是太高了

当数据在磁盘中时，磁盘 IO 会成为最大的性能瓶颈，所以应该尽量减少 IO 次数。而树的高度越高，增删改查所需要的 IO 次数也越多，会严重影响性能

### B 树（B-Tree）

为磁盘等辅存设备设计的多路平衡查找树，与二叉树相比，B 树的每个非叶节点可以有多个子树。因此，当总节点数量相同时，B 树的高度远远小于 AVL 树和红黑树，磁盘 IO 次数大大减少

![](./md.assets/b_tree.png)

<small>[B树和B+树的插入、删除图文详解 - B树](https://www.cnblogs.com/nullzx/p/8729425.html)</small>

B 树的优势除了树高小，还有对访问局部性原理的利用

- 局部性原理，是指当一个数据被使用时，其附近的数据有较大概率在短时间内被使用

### B+ 树（B+ Tree）

B+ 树是 B 树的一种变体

![](./md.assets/b+_tree.png)

<small>[B树和B+树的插入、删除图文详解 - B+树](https://www.cnblogs.com/nullzx/p/8729425.html)</small>

#### 与 B 树的区别

- B 树的所有节点既存储 key，又存储 data。B+ 树只有叶子节点存储 data，其他节点只存储 key
  - B+ 树的一个节点可以存储更多的 key，使得 B+ 树相对于 B 树来说会更矮，磁盘 IO 次数也就更少
- B+ 树的叶子节点之间通过双向链表链接，并按照索引列的值进行排序，能更好支持范围查找
  - B 树进行范围查询时，要先找到查找的下限，然后对 B 树进行中序遍历，直到找到查找的上限
  - B+ 树进行范围查询时，只需要遍历链表即可
- B+ 树的查询效率更稳定，任何查找都是从根节点到叶子节点的过程。而 B 树每个节点都可能查找到数据，可能还没有到达叶子节点，检索就结束了，所以不稳定

B+ 树与 B 树相比，具备更少的 IO 次数、更稳定的查询效率和更适于范围查询这些优势

### 哈希表（Hash）

哈希表是键值对的集合，通过 key 即可快速取出对应的 value，因此哈希表可以快速检索数据，接近 O(1)

使用了哈希表，就一定会发生哈希冲突，数据量越大，发生冲突的概率也就越大。哈希冲突会产生性能损耗，并影响查询效率

哈希索引不支持顺序和范围查询，因为哈希表中数据是无序的

InnoDB 存储引擎不直接支持常规的哈希索引，但是，InnoDB 存储引擎中存在一种特殊的自适应哈希索引（Adaptive Hash Index）

自适应哈希索引结合了 B+ 树和哈希索引的特点，每个哈希桶实际上是一个小型的 B+ 树结构。这个 B+ 树结构可以存储多个键值对，而不仅仅是一个键。这有助于减少哈希冲突链的长度，提高了索引的效率

## 聚簇索引（Clustered Index）与非聚簇索引（Non-Clustered Index）

聚簇索引是索引结构和数据一起存放的索引，并不是一种单独的索引类型。InnoDB 中的主键索引就属于聚簇索引

- 查询速度非常快：因为整个 B+ 树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据
- 对排序查找和范围查找优化：对于索引列的排序查找和范围查找速度非常快
- 依赖于有序的数据：如果索引的数据不是有序的，那么就需要在插入时排序

非聚簇索引是索引结构和数据分开存放的索引，并不是一种单独的索引类型。二级索引就属于非聚簇索引

非聚簇索引的叶子节点可以存放数据的指针，也可以存放主键值

- 依赖于有序的数据
- 可能会二次查询：即回表，查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询

### 主键索引

InnoDB 会自动的为每个表创建一个主键索引，叶子节点存储的是完整的用户记录

1. 优先使用用户自定义主键
2. 如果没有用户自定义主键，则选取一个 Unique 键
3. 如果没有 Unique 键，则 InnoDB 会为表默认添加一个名为 row_id 的隐藏列作为主键

### 二级索引

叶子节点存储的是主键值。唯一索引、普通索引、前缀索引、全文索引等都属于二级索引

## 回表

由于二级索引中只包含索引列和主键，主键索引是包含完整的用户记录数据的。当同时需要获取其他非索引列的数据时，就需要进行回表，即用从二级索引中获取到的主键值，再去主键索引中进行查询

### 覆盖索引

为了避免回表操作带来的性能损耗，在搜索条件中最好只包含索引列，这样就不必到聚簇索引中再查找记录的剩余列

## 索引下推（ICP，Index Condition Pushdown）

存储引擎在索引遍历过程中，执行部分 `WHERE` 字句的判断条件，直接过滤掉不满足条件的记录，从而减少回表次数，提高查询效率

MySQL 服务器程序分为 server 层和存储引擎层，在没有索引下推前

1. server 层首先调用存储引擎的接口定位到满足某一条件的第一条记录
2. 存储引擎根据该二级索引记录的主键值进行回表操作，将完整的用户记录返回给 server 层
3. server 层再判断其他的搜索条件是否成立，如果成立则将其发送给客户端，否则的话跳过该记录，然后向存储引擎层要下一条记录
4. 重复以上步骤，直到找到所有符合条件的记录

在有了索引下推后

1. server 层首先调用存储引擎的接口定位到满足某一条件的第一条记录
2. 存储引擎先不进行回表操作，而是去判断其他搜索条件是否成立（同一索引中的列，包括主键），如果成立，则执行回表操作，否则的话跳过该记录
3. server 层再判断其他的搜索条件是否成立，如果成立则将其发送给客户端，否则的话跳过该记录，然后向存储引擎层要下一条记录
4. 重复以上步骤，直到找到所有符合条件的记录

## 优缺点

使用索引可以大大加快数据的检索速度。通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性

创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。索引需要使用物理文件存储，也会耗费一定空间

## 索引创建建议

### 为合适的字段创建索引

- 不为 NULL 的字段
- 被作为条件查询的字段
- 频繁用于查询、排序、连接、分组的字段

### 考虑列的基数

列的基数指的是某一列中不重复数据的个数，在记录行数一定的情况下，列的基数越大，该列中的值越分散，列的基数越小，该列中的值越集中

列中的重复值多了，那么使用这个二级索引查出的记录还可能要做大量回表操作，这样性能损耗就更大了

最好为那些列的基数大的列建立索引，为基数太小列的建立索引效果可能不好

### 索引列的类型尽量小

- 数据类型越小，在查询时进行的比较操作越快（CPU 层次的操作）
- 数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以放下更多的记录，从而减少磁盘 I/O 带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率

主键更建议使用尽可能小的数据类型，因为聚簇索引、二级索引都会存储主键值，使用更小的数据类型，意味着节省更多的存储空间和更高效的 I/O

### 索引字符串值的前缀

我们在 MySQL 中常用 utf8 字符集去存储字符串，编码一个字符需要占用 1 ~ 3 个字节。如果字符串很长，那存储一个字符串就需要占用很大的存储空间，并且建立索引时，占用的空间也很大，做字符串比较也会占用更多的时间

可以只对字符串的前几个字符进行索引。这样在查找记录时虽然不能精确的定位到记录的位置，但是能定位到相应前缀所在的位置，然后根据前缀相同的记录的主键值回表查询完整的字符串值，再对比就好了

```sql
CREATE TABLE person_info(
    name VARCHAR(100) NOT NULL,
    birthday DATE NOT NULL,
    phone_number CHAR(11) NOT NULL,
    country varchar(100) NOT NULL,
    KEY idx_name_birthday_phone_number (name(10), birthday, phone_number)
);    
```

`name(10)` 就表示在建立的 B+ 树索引中只保留记录的前 10 个字符的编码

### 避免重复冗余的索引

冗余和重复索引，只会增加维护的成本，并不会对搜索有什么好处

### 尽可能考虑组合索引

索引是需要占用磁盘空间的，如果一个表的索引过多，占用的空间也是很多的。如果使用联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升

### 不要在频繁更新的列上创建索引

虽然索引能带来查询上的效率，但是维护索引的成本也是不小的

### 使用 `EXPLAIN` 分析语句

使用 `EXPLAIN` 分析语句，查看语句是否走了索引，帮助我们更好的创建索引

## 索引使用建议

### 避免使用 `SELECT *`

应指定需要查询的字段，尽量确保这些字段都在索引中，尽可能避免回表操作

### 遵守最左匹配原则

搜索条件中可以不用包含全部联合索引中的列，可以只包含左边一个或左边连续多个列

其实建立索引，也就是进行一个排序操作，先按字段 A 排，字段 A 相同时，再按 B 排，依次类推。如果跳过字段 A，直接使用字段 B 是走不了索引的，因为字段 B 只有在字段 A 相同时，才是有序的

### 让索引列在比较表达式中单独出现

如果索引列在比较表达式中不是以单独列的形式出现，而是以某个表达式，或者函数调用形式出现的话，是用不到索引的

```sql
# 无法使用索引
WHERE my_col * 2 < 4

# 可以使用索引
WHERE my_col < 4/2
```

### 避免使用 `%` 开头的模糊查询

对于字符串类型的索引列来说，只匹配它的前缀也是可以快速定位记录，因为字符串在排序时，也是逐个比较字符的大小的

但使用 `%` 开头的模糊查询是不走索引的，类似违反最左匹配原则

### 使用 `OR`

使用 `OR` 子句时，前后出现的列都要是索引列才可以走索引

### 使用 `IN`、`NOT IN`、`IS NULL`、`IS NOT NULL`、`!=`、`>`、`<`、`>=`、`<=`、`BETWEEN`、`LIKE`

这些操作都会产生一个需要扫描的范围，也就是扫描区间

优化器会首先针对可能使用到的二级索引划分几个扫描区间，然后分别调查这些区间内有多少条记录，在这些扫描区间内的二级索引记录的总和占总共的记录数量的比例达到某个值时，优化器将放弃使用二级索引执行查询，转而采用全表扫描

也就是说取值范围较大时会导致索引失效，走全表扫描

### 排序

`ORDER BY` 的子句后边的列的顺序也必须按照索引列的顺序给出，当然也适用最左匹配原则

- 注意不可 `ASC`、`DESC` 混用

### 隐式转换

当操作符左右两边的数据类型不一致时，会发生隐式转换，可能会导致索引失效，触发全表扫描。查询字段是什么类型的，查询条件就要保持相同的类型

## 参考

- [MySQL 是怎样运行的：从根儿上理解 MySQL](https://juejin.cn/book/6844733769996304392)
- [B树和B+树的插入、删除图文详解](https://www.cnblogs.com/nullzx/p/8729425.html)
- [MySQL B+树相对于B树的区别及优势](https://juejin.cn/post/7117516433386373133)
- [【深入学习MySQL】MySQL的索引结构为什么使用B+树？](https://www.cnblogs.com/kismetv/p/11582214.html)
- [MySQL索引详解](https://javaguide.cn/database/mysql/mysql-index.html)
